// This file contains the geological model implementation.

abstract class GeoObject (hidden GeoObject above,   // Another geological object
                          hidden GeoObject below,   // Another geological object
                          hidden GeoObject left,    // Another geological object
                          hidden GeoObject right,   // Another geological object
                          hidden GeoObject behind,  // Another geological object
                          hidden GeoObject front,   // Another geological object
                          hidden Double size)       // Represent the object's dimensions

    // Recursively calculates the total size of all geological objects above the current object.
    Double getSizeAbove()
        if(this.above == null) then return 0.0;
        else
            Double a = this.above.size;
            Double b = this.above.getSizeAbove();
            return a+b;
        end
    end

    // Because it is an abstract method, the actual implementation of update() must be provided by the subclasses that inherit from GeoObject.
    abstract Unit update()

    // Update the current object and recursively updates all objects above it
    Unit updateAll()
        this.update();
        if(this.above != null) then
            this.above.updateAll();
        end
    end

    // An abstract method that subclasses implement to indicate if the geological object can act as a cap/seal
    abstract Boolean caps()

    // An abstract method for subclasses to implement adding a new unit to the geological object.
    abstract Unit addUnit()

    // An abstract method for subclasses to implement printing the object's state
    abstract Unit printState()
end

// The Fault class is the most basic implementation of GeoObject.
class Fault extends GeoObject ()
    override Unit update()
        skip;
    end
    override Unit addUnit()
        skip;
    end
    override Boolean caps()
        return False;
    end
    override Unit printState()
        skip;
    end

end

// Extend GeoObject by adding one additional field: mergeId.
abstract class GeoUnit extends GeoObject (hidden Int mergeId)

    // New abstract method
    abstract GeoUnit clone()

    // Checks if two units can be merged by comparing their mergeIds
    /*@ requires other != null @*/
    Boolean canMerge(GeoUnit other)
        return other.mergeId == this.mergeId;
    end

    // Merges two units by adding their sizes together
    /*@ requires other != null @*/
    Unit mergeWith(GeoUnit other)
        this.size = this.size + other.size;
    end
end

// This class represents chalk geological formations. It is modelling hydrocarbon migration through chalk formations, with tracking of organic matter maturation and movement.
class ChalkUnit extends GeoUnit (List<Double> kerogenUnits)
    models "a <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_geological_object>; <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_constituted_by> _:fr1. _:fr1 a domain:chalk. ";

    override Unit update()
        List<Double> l = this.kerogenUnits;

        // Iterates through each kerogen unit in the list
        while l != null do
            Double next = l.content;
            if next >= 0 then

                // If there is room in the current unit (value + 100 is less than unit size), increases the hydrocarbon content by 100.
                if next + 100.0 < this.size then
                    l.content = next + 100;
                // If there is not enough room
                else
                    // Checks if there is a unit above and if it acts as a seal/cap
                    if this.above != null then
                        Boolean caps = this.above.caps();
                        // This simulates hydrocarbons migrating upwards.
                        // If there is a unit above and it is not a seal:
                        if !caps then
                            // Adds a new hydrocarbon unit to the layer above
                            this.above.addUnit();
                            // Marks current unit as processed (-1.0)
                            l.content = -1.0;
                        // This simulates hydrocarbon accumulation beneath a seal
                        // If there is a unit above and it is a seal:
                        else
                            // Sets content to maximum size
                            l.content = this.size;
                            // Prints "trap" to indicate hydrocarbons are trapped below seal
                            print("trap");
                        end
                    // This simulates hydrocarbons escaping at the surface.
                    // If there is no unit above:
                    else
                        // Prints "leak"
                        print("leak");
                        l.content = -1.0;
                    end
                end
                l = l.next;
            end
        end
    end

    // Creates a copy of the ChalkUnit
    override GeoUnit clone()
        GeoUnit g = new ChalkUnit(null, null, null, null, null, null, this.size, this.mergeId, this.kerogenUnits);
        return g;
    end

    // Returns False (chalk does not act as a seal)
    override Boolean caps() return False; end

    // Adds a new kerogen unit with initial value 0.0
    override Unit addUnit() this.kerogenUnits = new List<Double>(0.0, this.kerogenUnits); end

    // Prints the size of the chalk unit
    override Unit printState()
        print("Chalk at: ");
        print(this.size);
    end
end

// The main difference between SandstoneUnit and ChalkUnit is in their ontological representation - one is defined as sandstone and the other as chalk. Their behaviour regarding hydrocarbon migration is identical.
class SandstoneUnit extends GeoUnit (List<Double> kerogenUnits)
    models "a <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_geological_object>; <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_constituted_by> _:fr1. _:fr1 a domain:sandstone. ";

    override Unit update()
        List<Double> l = this.kerogenUnits;
        while l != null do
            Double next = l.content;
            if next >= 0 then
                if next + 100.0 < this.size then
                    l.content = next + 100;
                else
                    if this.above != null then
                        Boolean caps = this.above.caps();
                        if !caps then
                            this.above.addUnit();
                            l.content = -1.0;
                        else
                            l.content = this.size;
                            print("trap");
                        end
                    else
                        print("leak");
                        l.content = -1.0;
                    end
                end
                l = l.next;
            end
        end
    end

    override GeoUnit clone()
        GeoUnit g = new SandstoneUnit(null, null, null, null, null, null, this.size, this.mergeId, this.kerogenUnits);
        return g;
    end
    override Boolean caps() return False; end
    override Unit addUnit() this.kerogenUnits = new List<Double>(0.0, this.kerogenUnits); end
    override Unit printState()
        print("Sandstone at: ");
        print(this.size);
    end
end

// null, null, null, null, null, null, 40.0, 1, 0.0, True, 0
class ShaleUnit extends GeoUnit (hidden Double temperature, hidden Boolean hasKerogenSource, hidden Int maturedUnits)
    models "a <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoReservoirOntology_sedimentary_geological_object>; obo:RO_0001015 _:fr3; <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_constituted_by> _:fr1; obo:RO_0000086 _:fr2. _:fr1 a domain:shale. _:fr2 domain:datavalue %temperature; a domain:temperature. _:fr3 a domain:amount_of_organic_matter.";

    override Unit update()
        Double under = this.getSizeAbove();
        // Increase temperature based on how much overburden (under) is on top. The more rock layers above, the hotter the shale becomes.
        this.temperature = 2.5 + ((under/1000) * 30);
        if this.maturedUnits > 0 then
            if this.above != null then
                Boolean caps = this.above.caps();
                if !caps then
                    this.above.addUnit();
                    this.maturedUnits = this.maturedUnits - 1;
                    print("migrate from shale");
                else
                    print("trap in shale");
                end
            else
                print("leak from shale");
                this.maturedUnits = this.maturedUnits - 1;
            end
        end
    end

    override GeoUnit clone()
        GeoUnit g = new ShaleUnit(null, null, null, null, null, null, this.size, this.mergeId, this.temperature, this.hasKerogenSource, this.maturedUnits);
        return g;
    end

    // This simulates the idea that kerogen-containing shales generate (mature) new hydrocarbons over time.
    Unit mature()
        // If the shale has a kerogen source (this.hasKerogenSource == true), calling mature() increases the maturedUnits count by one.
        if this.hasKerogenSource then
            this.maturedUnits = this.maturedUnits + 1;
            print(">> maturation on-going!");
            Double under = this.getSizeAbove();
            print(">> depth");
            print(under);
            print(">> temp");
            print(this.temperature);
        end
    end

    override Boolean caps() return True; end
    override Unit addUnit() skip; end
    override Unit printState()
        print("Shale at: ");
        print(this.size);
    end
end


hidden class DepositionGenerator(GeoUnit emitUnit, Double duration, Int times)
    GeoUnit emit()
        GeoUnit next = this.emitUnit.clone();
        this.times = this.times - 1;
        return next;
    end
end

/*
Driver is the high-level simulation “controller.” Driver is responsible for:
1. Initializing the geological column with a given “bottom” rock unit.
2. Iterating over a sequence of deposition events (represented by DepositionGenerators).
3. Adding new units onto the top of the existing column, or merging them when possible.
4. Calling updates on all units from bottom to top (via updateAll).
5. Triggering additional domain logic (e.g., shale maturation) at the right simulation times.
6. Printing progress (time steps) and the final state.
*/

hidden class Driver(GeoUnit top, GeoUnit bottom)
    // dl, 136.0, mandal, (-66.0)
   Unit sim(List<DepositionGenerator> actions, Double startPast, GeoUnit init, Double checkStart)
        // "init" is the initial geological unit, often a ShaleUnit at the bottom.
        this.top = init;
        this.bottom = init;

        /*
        If startPast = 136.0, then now starts at -136.0.
        The code uses negative time as a way to say “136 million years ago,” for instance.
        */
        Double now = -1.0 * startPast;

        // "actions" is a linked list of DepositionGenerators.
        List<DepositionGenerator> work = actions;
        while work != null do
            DepositionGenerator dg = work.content;
            // Each DepositionGenerator has an integer field times indicating how many times (or how many layers) to deposit. This loop repeats until there are no more layers to deposit (i.e., dg.times becomes 0).
            while dg.times > 0 do

                /*
                Makes a clone of the generator’s prototype unit (dg.emitUnit). Decrements dg.times by 1.
                So on each iteration, we get a fresh new GeoUnit (e.g., a SandstoneUnit or ShaleUnit) ready to be placed in the geological column.
                */
                GeoUnit un = dg.emit();

                /*
                Check whether the newly created unit can be merged with the current top.
                canMerge(...) returns true if both units have the same mergeId (defined in GeoUnit), indicating they are of the same “mergeable” type (e.g., same rock layer or same deposit sequence).
                */
                Boolean bb = this.top.canMerge(un);

                if bb then  // bb == true, units can merge
                    /*
                    Merge the new unit with the top.
                    Merging adds the sizes of both units into the existing top unit.
                    The new "un" is no longer needed as a separate layer, so we destroy(un) to free it.
                    */
                    this.top.mergeWith(un);
                    destroy(un);
                else        // bb == false, units cannot merge
                    /*
                    Stack the new unit on top.
                    The new unit sits above the old top.
                    Update the top pointer to this newly added unit.
                    */
                    this.top.above = un;
                    this.top = un;
                    un.below = this.top;    // THIS LINE REQUIRES REVISION
                end

                // Advance the simulation time (now) by the duration (dg.duration) of the deposition event.
                now = now + dg.duration;

                /*
                Trigger each geological unit (bottom to top) to run its update() method.
                - ShaleUnits might increment their temperature, expel hydrocarbons if matured.
                - ChalkUnits or SandstoneUnits might handle kerogen migration.
                - Fault objects might do nothing (they override update() with skip;).
                */
                this.bottom.updateAll();

                print("> Updating simulation with t =");
                print(now);
                this.printState(this.bottom);

                /*
                "checkStart" is a threshold time. Once "now" exceeds it, the code runs a domain-specific query.
                This block simulates a scenario where, after a certain time (or geologic period), the shales enter a “window” for generating hydrocarbons.
                */
                if now > checkStart  then
                    List<ShaleUnit> fs = member("<domain:models> some (<obo:RO_0000056> some <domain:oil_window_maturation_trigger>)");
                    print("reasoning finished");

                    while fs != null do
                      // For each such shale, increment maturedUnits if it has a kerogen source.
                      fs.content.mature();
                      List<ShaleUnit> os = fs;
                      fs = fs.next;
                      destroy(os);
                    end
                end
            end
            destroy(dg.emitUnit);
            destroy(dg);
            List<DepositionGenerator> s = work;
            work = work.next;
            destroy(s);
        end
        print("> Ending simulation with t =-");
        print(now);
   end

   Unit printState(GeoObject fromBelow)
        if fromBelow != null then
            fromBelow.printState();
            this.printState(fromBelow.above);
        end
   end
end

main
    // Create the initial (bottom) geological unit.
    ShaleUnit mandal = new ShaleUnit(null, null, null, null, null, null, 20.0, 1, 0.0, True, 0);
    List<DepositionGenerator> dl = null;

    // Defines a series of DepositionGenerator objects, each describing how to deposit new units (sandstone or chalk, plus one additional shale “cap”) on top of the current column.
    SandstoneUnit div = new SandstoneUnit(null, null, null, null, null, null, 26.5, 2, null);
    DepositionGenerator dep = new DepositionGenerator(div, 2.0, 31);
    dl = new List<DepositionGenerator>(dep, dl);

    SandstoneUnit tor = new ChalkUnit(null, null, null, null, null, null, 67.5, 2, null);
    DepositionGenerator depTor = new DepositionGenerator(tor, 2.0, 5);
    dl = new List<DepositionGenerator>(depTor, dl);

    SandstoneUnit ekofisk = new ChalkUnit(null, null, null, null, null, null, 99.0, 2, null);
    DepositionGenerator depEko = new DepositionGenerator(ekofisk, 2.0, 1);
    dl = new List<DepositionGenerator>(depEko, dl);

    ShaleUnit cap = new ShaleUnit(null, null, null, null, null, null, 30.0, 1, 0.0, False, 0); //mudstone is modelled as shale
    DepositionGenerator depCap = new DepositionGenerator(cap, 2.0, 1);
    dl = new List<DepositionGenerator>(depCap, dl);

    SandstoneUnit ab1 = new SandstoneUnit(null, null, null, null, null, null, 186.0, 2, null);
    DepositionGenerator depAb1 = new DepositionGenerator(ab1, 2.0, 5);
    dl = new List<DepositionGenerator>(depAb1, dl);

    SandstoneUnit ab2 = new SandstoneUnit(null, null, null, null, null, null, 98.05, 2, null);
    DepositionGenerator depAb2 = new DepositionGenerator(ab2, 2.0, 26);
    dl = new List<DepositionGenerator>(depAb2, dl);

    // Run the simulation using the Driver.
    dl = dl.reverse();

    Driver driver = new Driver(null,null);
    driver.sim(dl, 136.0, mandal, (-66.0));
end