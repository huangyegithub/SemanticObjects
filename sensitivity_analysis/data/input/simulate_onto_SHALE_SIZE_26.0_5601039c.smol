// ============================================
// GENERATED BY SENSITIVITY ANALYSIS TOOL
// Generated: 2025-08-07 10:28:56
// Source: ../templates/simulate_onto_template.smol
// ============================================
// Modified Parameters:
// - SHALE_SIZE: 20.0 -> 26.0 (+30.0%)
// Description:
// SHALE_SIZE = 26.0
// ============================================

// This file contains the geological model implementation with parameterization support.
// This is a template version for sensitivity analysis with {{PARAMETER_NAME}} placeholders.

// ========================================================================
// CONFIGURATION CLASS FOR SENSITIVITY ANALYSIS
// ========================================================================
// This class centralizes all parameters that were previously hardcoded
// throughout the simulation, enabling systematic sensitivity analysis
class SimConfig(
    // Geological unit sizes (meters)
    Double shaleSize,        // Base: 20.0
    Double sandstoneSize,    // Base: 26.5
    Double torSize,          // Base: 67.5
    Double ekofiskSize,      // Base: 99.0
    Double capSize,          // Base: 30.0
    Double ab1Size,          // Base: 186.0
    Double ab2Size,          // Base: 98.05
    
    // Temperature model parameters
    Double baseTemperature,  // Base: 2.5 celsius
    Double tempFactor,       // Base: 30.0 celsius/km
    
    // Hydrocarbon migration parameters
    Double hydrocarbonIncrement,  // Base: 100.0
    
    // Temporal parameters (million years)
    Double startPast,        // Base: 136.0
    Double checkStart,       // Base: -66.0
    Double depositionDuration,  // Base: 2.0
    
    // Layer counts
    Int divLayers,           // Base: 31
    Int torLayers,           // Base: 5
    Int ekofiskLayers,       // Base: 1
    Int capLayers,           // Base: 1
    Int ab1Layers,           // Base: 5
    Int ab2Layers            // Base: 26
)
end

// ========================================================================
// GEOLOGICAL OBJECT CLASSES (unchanged from original)
// ========================================================================

abstract class GeoObject (hidden GeoObject above,   // Another geological object
                          hidden GeoObject below,   // Another geological object
                          hidden GeoObject left,    // Another geological object
                          hidden GeoObject right,   // Another geological object
                          hidden GeoObject behind,  // Another geological object
                          hidden GeoObject front,   // Another geological object
                          hidden Double size)       // Represent the object's dimensions

    // Recursively calculates the total size of all geological objects above the current object.
    Double getSizeAbove()
        if(this.above == null) then return 0.0;
        else
            Double a = this.above.size;
            Double b = this.above.getSizeAbove();
            return a+b;
        end
    end

    // Because it is an abstract method, the actual implementation of update() must be provided by the subclasses that inherit from GeoObject.
    abstract Unit update()

    // Update the current object and recursively updates all objects above it
    Unit updateAll()
        this.update();
        if(this.above != null) then
            this.above.updateAll();
        end
    end

    // An abstract method that subclasses implement to indicate if the geological object can act as a cap/seal
    abstract Boolean caps()

    // An abstract method for subclasses to implement adding a new unit to the geological object.
    abstract Unit addUnit()

    // An abstract method for subclasses to implement printing the object's state
    abstract Unit printState()
end

// The Fault class is the most basic implementation of GeoObject.
class Fault extends GeoObject ()
    override Unit update()
        skip;
    end
    override Unit addUnit()
        skip;
    end
    override Boolean caps()
        return False;
    end
    override Unit printState()
        skip;
    end

end

// Extend GeoObject by adding one additional field: mergeId.
abstract class GeoUnit extends GeoObject (hidden Int mergeId)

    // New abstract method
    abstract GeoUnit clone()

    // Checks if two units can be merged by comparing their mergeIds
    /*@ requires other != null @*/
    Boolean canMerge(GeoUnit other)
        return other.mergeId == this.mergeId;
    end

    // Merges two units by adding their sizes together
    /*@ requires other != null @*/
    Unit mergeWith(GeoUnit other)
        this.size = this.size + other.size;
    end
end

// ========================================================================
// MODIFIED CHALK UNIT WITH CONFIGURATION SUPPORT
// ========================================================================
// This class represents chalk geological formations with parameterized hydrocarbon migration
class ChalkUnit extends GeoUnit (List<Double> kerogenUnits, hidden SimConfig config)
    models "a <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_geological_object>; <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_constituted_by> _:fr1. _:fr1 a domain:chalk. ";

    override Unit update()
        List<Double> l = this.kerogenUnits;

        // Iterates through each kerogen unit in the list
        while l != null do
            Double next = l.content;
            if next >= 0 then

                // PARAMETERIZED: Using config.hydrocarbonIncrement instead of hardcoded 100.0
                if next + this.config.hydrocarbonIncrement < this.size then
                    l.content = next + this.config.hydrocarbonIncrement;
                // If there is not enough room
                else
                    // Checks if there is a unit above and if it acts as a seal/cap
                    if this.above != null then
                        Boolean caps = this.above.caps();
                        // This simulates hydrocarbons migrating upwards.
                        // If there is a unit above and it is not a seal:
                        if !caps then
                            // Adds a new hydrocarbon unit to the layer above
                            this.above.addUnit();
                            // Marks current unit as processed (-1.0)
                            l.content = -1.0;
                        // This simulates hydrocarbon accumulation beneath a seal
                        // If there is a unit above and it is a seal:
                        else
                            // Sets content to maximum size
                            l.content = this.size;
                            // Prints "trap" to indicate hydrocarbons are trapped below seal
                            print("trap");
                        end
                    // This simulates hydrocarbons escaping at the surface.
                    // If there is no unit above:
                    else
                        // Prints "leak"
                        print("leak");
                        l.content = -1.0;
                    end
                end
                l = l.next;
            end
        end
    end

    // Creates a copy of the ChalkUnit
    override GeoUnit clone()
        GeoUnit g = new ChalkUnit(null, null, null, null, null, null, this.size, this.mergeId, this.kerogenUnits, this.config);
        return g;
    end

    // Returns False (chalk does not act as a seal)
    override Boolean caps() return False; end

    // Adds a new kerogen unit with initial value 0.0
    override Unit addUnit() this.kerogenUnits = new List<Double>(0.0, this.kerogenUnits); end

    // Prints the size of the chalk unit
    override Unit printState()
        print("Chalk at: ");
        print(this.size);
    end
end

// ========================================================================
// MODIFIED SANDSTONE UNIT WITH CONFIGURATION SUPPORT
// ========================================================================
class SandstoneUnit extends GeoUnit (List<Double> kerogenUnits, hidden SimConfig config)
    models "a <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_geological_object>; <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_constituted_by> _:fr1. _:fr1 a domain:sandstone. ";

    override Unit update()
        List<Double> l = this.kerogenUnits;
        while l != null do
            Double next = l.content;
            if next >= 0 then
                // PARAMETERIZED: Using config.hydrocarbonIncrement instead of hardcoded 100.0
                if next + this.config.hydrocarbonIncrement < this.size then
                    l.content = next + this.config.hydrocarbonIncrement;
                else
                    if this.above != null then
                        Boolean caps = this.above.caps();
                        if !caps then
                            this.above.addUnit();
                            l.content = -1.0;
                        else
                            l.content = this.size;
                            print("trap");
                        end
                    else
                        print("leak");
                        l.content = -1.0;
                    end
                end
                l = l.next;
            end
        end
    end

    override GeoUnit clone()
        GeoUnit g = new SandstoneUnit(null, null, null, null, null, null, this.size, this.mergeId, this.kerogenUnits, this.config);
        return g;
    end
    override Boolean caps() return False; end
    override Unit addUnit() this.kerogenUnits = new List<Double>(0.0, this.kerogenUnits); end
    override Unit printState()
        print("Sandstone at: ");
        print(this.size);
    end
end

// ========================================================================
// MODIFIED SHALE UNIT WITH CONFIGURATION SUPPORT
// ========================================================================
class ShaleUnit extends GeoUnit (hidden Double temperature, hidden Boolean hasKerogenSource, hidden Int maturedUnits, hidden SimConfig config)
    models "a <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoReservoirOntology_sedimentary_geological_object>; obo:RO_0001015 _:fr3; <http://purl.obolibrary.org/obo/bfo.owl#UFRGS:GeoCoreOntology_constituted_by> _:fr1; obo:RO_0000086 _:fr2. _:fr1 a domain:shale. _:fr2 domain:datavalue %temperature; a domain:temperature. _:fr3 a domain:amount_of_organic_matter.";

    override Unit update()
        Double under = this.getSizeAbove();
        // PARAMETERIZED: Using config.baseTemperature and config.tempFactor instead of hardcoded 2.5 and 30
        this.temperature = this.config.baseTemperature + ((under/1000) * this.config.tempFactor);
        if this.maturedUnits > 0 then
            if this.above != null then
                Boolean caps = this.above.caps();
                if !caps then
                    this.above.addUnit();
                    this.maturedUnits = this.maturedUnits - 1;
                    print("migrate from shale");
                else
                    print("trap in shale");
                end
            else
                print("leak from shale");
                this.maturedUnits = this.maturedUnits - 1;
            end
        end
    end

    override GeoUnit clone()
        GeoUnit g = new ShaleUnit(null, null, null, null, null, null, this.size, this.mergeId, this.temperature, this.hasKerogenSource, this.maturedUnits, this.config);
        return g;
    end

    // This simulates the idea that kerogen-containing shales generate (mature) new hydrocarbons over time.
    Unit mature()
        // If the shale has a kerogen source (this.hasKerogenSource == true), calling mature() increases the maturedUnits count by one.
        if this.hasKerogenSource then
            this.maturedUnits = this.maturedUnits + 1;
            print(">> maturation on-going!");
            Double under = this.getSizeAbove();
            print(">> depth");
            print(under);
            print(">> temp");
            print(this.temperature);
        end
    end

    override Boolean caps() return True; end
    override Unit addUnit() skip; end
    override Unit printState()
        print("Shale at: ");
        print(this.size);
    end
end

// ========================================================================
// DEPOSITION GENERATOR (unchanged from original)
// ========================================================================
hidden class DepositionGenerator(GeoUnit emitUnit, Double duration, Int times)
    GeoUnit emit()
        GeoUnit next = this.emitUnit.clone();
        this.times = this.times - 1;
        return next;
    end
end

// ========================================================================
// DRIVER CLASS (unchanged from original)
// ========================================================================
/*
Driver is the high-level simulation "controller." Driver is responsible for:
1. Initializing the geological column with a given "bottom" rock unit.
2. Iterating over a sequence of deposition events (represented by DepositionGenerators).
3. Adding new units onto the top of the existing column, or merging them when possible.
4. Calling updates on all units from bottom to top (via updateAll).
5. Triggering additional domain logic (e.g., shale maturation) at the right simulation times.
6. Printing progress (time steps) and the final state.
*/

hidden class Driver(GeoUnit top, GeoUnit bottom)
   Unit sim(List<DepositionGenerator> actions, Double startPast, GeoUnit init, Double checkStart)
        // "init" is the initial geological unit, often a ShaleUnit at the bottom.
        this.top = init;
        this.bottom = init;

        /*
        If startPast = 136.0, then now starts at -136.0.
        The code uses negative time as a way to say "136 million years ago," for instance.
        */
        Double now = -1.0 * startPast;

        // "actions" is a linked list of DepositionGenerators.
        List<DepositionGenerator> work = actions;
        while work != null do
            DepositionGenerator dg = work.content;
            // Each DepositionGenerator has an integer field times indicating how many times (or how many layers) to deposit. This loop repeats until there are no more layers to deposit (i.e., dg.times becomes 0).
            while dg.times > 0 do

                /*
                Makes a clone of the generator's prototype unit (dg.emitUnit). Decrements dg.times by 1.
                So on each iteration, we get a fresh new GeoUnit (e.g., a SandstoneUnit or ShaleUnit) ready to be placed in the geological column.
                */
                GeoUnit un = dg.emit();

                /*
                Check whether the newly created unit can be merged with the current top.
                canMerge(...) returns true if both units have the same mergeId (defined in GeoUnit), indicating they are of the same "mergeable" type (e.g., same rock layer or same deposit sequence).
                */
                Boolean bb = this.top.canMerge(un);

                if bb then  // bb == true, units can merge
                    /*
                    Merge the new unit with the top.
                    Merging adds the sizes of both units into the existing top unit.
                    The new "un" is no longer needed as a separate layer, so we destroy(un) to free it.
                    */
                    this.top.mergeWith(un);
                    destroy(un);
                else        // bb == false, units cannot merge
                    /*
                    Stack the new unit on top.
                    The new unit sits above the old top.
                    Update the top pointer to this newly added unit.
                    */
                    this.top.above = un;
                    this.top = un;
                    un.below = this.top;    // THIS LINE REQUIRES REVISION
                end

                // Advance the simulation time (now) by the duration (dg.duration) of the deposition event.
                now = now + dg.duration;

                /*
                Trigger each geological unit (bottom to top) to run its update() method.
                - ShaleUnits might increment their temperature, expel hydrocarbons if matured.
                - ChalkUnits or SandstoneUnits might handle kerogen migration.
                - Fault objects might do nothing (they override update() with skip;).
                */
                this.bottom.updateAll();

                print("> Updating simulation with t =");
                print(now);
                this.printState(this.bottom);

                /*
                "checkStart" is a threshold time. Once "now" exceeds it, the code runs a domain-specific query.
                This block simulates a scenario where, after a certain time (or geologic period), the shales enter a "window" for generating hydrocarbons.
                */
                if now > checkStart  then
                    List<ShaleUnit> fs = member("<domain:models> some (<obo:RO_0000056> some <domain:oil_window_maturation_trigger>)");
                    print("reasoning finished");

                    while fs != null do
                      // For each such shale, increment maturedUnits if it has a kerogen source.
                      fs.content.mature();
                      List<ShaleUnit> os = fs;
                      fs = fs.next;
                      destroy(os);
                    end
                end
            end
            destroy(dg.emitUnit);
            destroy(dg);
            List<DepositionGenerator> s = work;
            work = work.next;
            destroy(s);
        end
        print("> Ending simulation with t =-");
        print(now);
   end

   Unit printState(GeoObject fromBelow)
        if fromBelow != null then
            fromBelow.printState();
            this.printState(fromBelow.above);
        end
   end
end

// ========================================================================
// PARAMETERIZED MAIN BLOCK WITH PLACEHOLDERS
// ========================================================================
main
    // Create configuration with all parameters (using placeholders)
    SimConfig config = new SimConfig(
        // Geological unit sizes
        26.0,         // shaleSize
        26.50,     // sandstoneSize
        67.50,           // torSize
        99.0,       // ekofiskSize
        30.0,           // capSize
        186.0,           // ab1Size
        98.05,           // ab2Size
        
        // Temperature model
        2.50,   // baseTemperature
        30.0,        // tempFactor
        
        // Hydrocarbon migration
        100.0,  // hydrocarbonIncrement
        
        // Temporal parameters
        136.0,         // startPast
        -66.0,        // checkStart
        2.0, // depositionDuration
        
        // Layer counts
        31,         // divLayers
        5,         // torLayers
        1,     // ekofiskLayers
        1,         // capLayers
        5,         // ab1Layers
        26          // ab2Layers
    );

    // Create the initial (bottom) geological unit using config
    ShaleUnit mandal = new ShaleUnit(null, null, null, null, null, null, config.shaleSize, 1, 0.0, True, 0, config);
    List<DepositionGenerator> dl = null;

    // Create deposition generators using configuration values
    SandstoneUnit div = new SandstoneUnit(null, null, null, null, null, null, config.sandstoneSize, 2, null, config);
    DepositionGenerator dep = new DepositionGenerator(div, config.depositionDuration, config.divLayers);
    dl = new List<DepositionGenerator>(dep, dl);

    // Note: Original code has type mismatch here (SandstoneUnit tor = new ChalkUnit)
    // Fixed to use ChalkUnit type
    ChalkUnit tor = new ChalkUnit(null, null, null, null, null, null, config.torSize, 2, null, config);
    DepositionGenerator depTor = new DepositionGenerator(tor, config.depositionDuration, config.torLayers);
    dl = new List<DepositionGenerator>(depTor, dl);

    ChalkUnit ekofisk = new ChalkUnit(null, null, null, null, null, null, config.ekofiskSize, 2, null, config);
    DepositionGenerator depEko = new DepositionGenerator(ekofisk, config.depositionDuration, config.ekofiskLayers);
    dl = new List<DepositionGenerator>(depEko, dl);

    ShaleUnit cap = new ShaleUnit(null, null, null, null, null, null, config.capSize, 1, 0.0, False, 0, config); //mudstone is modelled as shale
    DepositionGenerator depCap = new DepositionGenerator(cap, config.depositionDuration, config.capLayers);
    dl = new List<DepositionGenerator>(depCap, dl);

    SandstoneUnit ab1 = new SandstoneUnit(null, null, null, null, null, null, config.ab1Size, 2, null, config);
    DepositionGenerator depAb1 = new DepositionGenerator(ab1, config.depositionDuration, config.ab1Layers);
    dl = new List<DepositionGenerator>(depAb1, dl);

    SandstoneUnit ab2 = new SandstoneUnit(null, null, null, null, null, null, config.ab2Size, 2, null, config);
    DepositionGenerator depAb2 = new DepositionGenerator(ab2, config.depositionDuration, config.ab2Layers);
    dl = new List<DepositionGenerator>(depAb2, dl);

    // Run the simulation using the Driver
    dl = dl.reverse();

    Driver driver = new Driver(null,null);
    driver.sim(dl, config.startPast, mandal, config.checkStart);
end